const Loan = require("../models/Loan");
const User = require("../models/Account");
const Book = require("../models/Book");
const { format } = require("date-fns");
const nodemailer = require("nodemailer");

// exports.createLoan = async (userEmail, bookID, phone, address, countDay, frontImage, backImage, note) => {
//     try {
//         const nowUTC = new Date();
//         const dayStart = new Date(nowUTC.getTime() + 7 * 60 * 60 * 1000); // Gi·ªù Vi·ªát Nam (UTC+7)

//         // Ki·ªÉm tra s·ªë ng√†y m∆∞·ª£n h·ª£p l·ªá
//         const countDayInt = parseInt(countDay, 10);
//         if (isNaN(countDayInt) || countDayInt <= 0) {
//             throw new Error("S·ªë ng√†y m∆∞·ª£n kh√¥ng h·ª£p l·ªá");
//         }

//         // T√≠nh ng√†y k·∫øt th√∫c
//         const dayEnd = new Date(dayStart);
//         dayEnd.setDate(dayEnd.getDate() + countDayInt);

//         // L·∫•y LoanID m·ªõi
//         const lastLoan = await Loan.findOne().sort({ LoanID: -1 });
//         const newLoanID = lastLoan ? lastLoan.LoanID + 1 : 1;

//         // T√¨m ng∆∞·ªùi d√πng
//         const user = await User.findOne({ Email: userEmail });
//         const userID = user._id;

//         // C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng
//         const userUpdate = await User.findByIdAndUpdate(
//             { _id: userID },
//             {
//                 Phone: phone,
//                 Address: address,
//                 FrontImage: frontImage[0].filename,  // L∆∞u t√™n file
//                 BackImage: backImage[0].filename     // L∆∞u t√™n file
//             },
//             { new: true }
//         );

//         if (!userUpdate) {
//             throw new Error("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng ƒë·ªÉ c·∫≠p nh·∫≠t");
//         }

//         // C·∫≠p nh·∫≠t s√°ch
//         const bookUpdate = await Book.findByIdAndUpdate(
//             { _id: bookID },
//             { Availability: "Unavailable" },
//             { new: true }
//         );

//         if (!bookUpdate) {
//             throw new Error("Kh√¥ng t√¨m th·∫•y s√°ch ƒë·ªÉ c·∫≠p nh·∫≠t");
//         }

//         // T·∫°o ƒë∆°n m∆∞·ª£n
//         const loan = await Loan.create({
//             LoanID: newLoanID,
//             AccountID: userID,
//             BookID: bookID,
//             DayStart: dayStart,
//             DayEnd: dayEnd,
//             Note: note,
//             State: "Y√™u c·∫ßu m∆∞·ª£n"
//         });

//         return loan;
//     } catch (error) {
//         console.error("Error in loanService.createLoan:", error.message);
//         throw error;
//     }
// };

const generateLoanCode = () => {
    const now = new Date();
    const datePart = now.toISOString().slice(0, 10).replace(/-/g, '');  // L·∫•y ng√†y theo ƒë·ªãnh d·∫°ng YYYYMMDD
    const randomPart = Math.floor(Math.random() * 10000); // T·∫°o m·ªôt s·ªë ng·∫´u nhi√™n t·ª´ 0 ƒë·∫øn 9999
    return `${datePart}-${randomPart}`;  // K·∫øt h·ª£p ng√†y v·ªõi s·ªë ng·∫´u nhi√™n ƒë·ªÉ t·∫°o LoanCode
};

exports.createLoan = async (code, bookID, countDay, note, method, payment) => {
    try {
        const nowUTC = new Date();
        const dayStart = new Date(nowUTC.getTime() + 7 * 60 * 60 * 1000); // Gi·ªù Vi·ªát Nam (UTC+7)

        // L·∫•y LoanID m·ªõi
        const lastLoan = await Loan.findOne().sort({ LoanID: -1 });
        const newLoanID = lastLoan ? lastLoan.LoanID + 1 : 1;

        // T√¨m ng∆∞·ªùi d√πng
        const user = await User.findOne({ LbCode: code });
        if (!user) {
            return { errCode: 1, message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" };
        }

        // Ki·ªÉm tra n·∫øu t√†i kho·∫£n b·ªã h·∫°n ch·∫ø
        if (user.State === "Limited") {
            return { errCode: 2, message: "T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã h·∫°n ch·∫ø, kh√¥ng th·ªÉ m∆∞·ª£n s√°ch." };
        }

        const userID = user._id;

        if (method === "M∆∞·ª£n v·ªÅ nh√†") {
            const countDayInt = parseInt(countDay, 10);
            if (isNaN(countDayInt) || countDayInt <= 0) {
                return { errCode: 3, message: "S·ªë ng√†y m∆∞·ª£n kh√¥ng h·ª£p l·ªá" };
            }

            const dayEnd = new Date(dayStart);
            dayEnd.setDate(dayEnd.getDate() + countDayInt);

            const bookUpdate = await Book.findByIdAndUpdate(
                bookID,
                { Availability: "Unavailable" },
                { new: true }
            );

            if (!bookUpdate) {
                return { errCode: 4, message: "Kh√¥ng t√¨m th·∫•y s√°ch ƒë·ªÉ c·∫≠p nh·∫≠t" };
            }

            const loan = await Loan.create({
                LoanID: newLoanID,
                LoanCode: generateLoanCode(),
                AccountID: userID,
                BookID: [bookID], 
                DayStart: dayStart,
                DayEnd: dayEnd,
                Method: "M∆∞·ª£n v·ªÅ nh√†",
                Payment: payment,
                Note: note,
                State: "Y√™u c·∫ßu m∆∞·ª£n"
            });

            return { errCode: 0, message: "T·∫°o ƒë∆°n th√†nh c√¥ng", loan };
        } else if (method === "M∆∞·ª£n t·∫°i ch·ªó") {
            const bookCodes = Array.isArray(bookID)
                ? bookID.map((b) => (typeof b === "object" ? b.code : b))
                : [typeof bookID === "object" ? bookID.code : bookID];
            const books = await Book.find({ BookCode: { $in: bookCodes } }, "_id");

            if (!books || books.length === 0) {
                return { errCode: 5, message: "Kh√¥ng t√¨m th·∫•y s√°ch v·ªõi m√£ BookCode ƒë√£ cho" };
            }

            const bookList = books.map(book => book._id);

            const loan = await Loan.create({
                LoanID: newLoanID,
                LoanCode: generateLoanCode(),
                AccountID: userID,
                BookID: bookList, 
                DayStart: dayStart,
                DayEnd: dayStart,
                Method: "M∆∞·ª£n t·∫°i ch·ªó",
                Payment: "Mi·ªÖn ph√≠",
                Note: note || "",
                State: "ƒêang m∆∞·ª£n"
            });

            return { errCode: 0, message: "T·∫°o ƒë∆°n th√†nh c√¥ng", loan };
        } else {
            return { errCode: 6, message: "H√¨nh th·ª©c m∆∞·ª£n kh√¥ng h·ª£p l·ªá" };
        }
    } catch (error) {
        console.error("Error in loanService.createLoan:", error.message);
        return { errCode: 500, message: "L·ªói h·ªá th·ªëng" };
    }
};

exports.getAllLoanSV = async (userEmail) => { 
    try {
        const user = await User.findOne({ Email: userEmail });
        if (!user) {
            throw new Error("Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i");
        }

        const role = user.Role;

        if (role == "user") {
            const loans = await Loan.find({ AccountID: user._id })
                .sort({ LoanID: -1 });

            // ƒê·∫£m b·∫£o tr·∫£ v·ªÅ ng√†y theo ƒë·ªãnh d·∫°ng ISO string
            const formattedLoans = loans.map((loan) => ({
                ...loan._doc, // B·∫£o to√†n c√°c tr∆∞·ªùng kh√°c
                DayStart: loan.DayStart.toISOString(),  // ƒê·ªãnh d·∫°ng d∆∞·ªõi d·∫°ng ISO string
                DayEnd: loan.DayEnd.toISOString(),     // ƒê·ªãnh d·∫°ng d∆∞·ªõi d·∫°ng ISO string
            }));

            return formattedLoans;
        } else if (role == "admin") {
            const loans = await Loan.find({})
                .sort({ LoanID: -1 });

            // ƒê·∫£m b·∫£o tr·∫£ v·ªÅ ng√†y theo ƒë·ªãnh d·∫°ng ISO string
            const formattedLoans = loans.map((loan) => ({
                ...loan._doc, // B·∫£o to√†n c√°c tr∆∞·ªùng kh√°c
                DayStart: loan.DayStart.toISOString(),  // ƒê·ªãnh d·∫°ng d∆∞·ªõi d·∫°ng ISO string
                DayEnd: loan.DayEnd.toISOString(),     // ƒê·ªãnh d·∫°ng d∆∞·ªõi d·∫°ng ISO string
            }));

            return formattedLoans;
        }    
    } catch (err) {
        console.error("L·ªói trong loanService.getAllLoanSV: ", err.message);
        throw err;
    }
};

exports.getALoanSV = async (loanID) => {
    try {
        return Loan.findById({ _id: loanID });
    } catch (err) {
        console.error("L·ªói trong getALoanSV: ", err.message);
        throw err;
    }
};

function getLibrarySignature() {
    return `
        <p style="margin-top: 30px; font-size: 14px; color: #555;">
            ‚Äî<br/>
            <strong>üìö Th∆∞ vi·ªán Tr∆∞·ªùng BokStory</strong><br/>
            üìß Email: <a href="mailto:${process.env.EMAIL_USER}">${process.env.EMAIL_USER}</a><br/>
            ‚òéÔ∏è Hotline: 096 440 6858<br/>
            üåê Truy c·∫≠p website ƒë·ªÉ bi·∫øt th√™m th√¥ng tin chi ti·∫øt.
        </p>
    `;
}

exports.acceptLoanSV = async (loanID, state) => {
    try {
        const loan = await Loan.findOne({ _id: loanID }).populate({
            path: "AccountID",
            select: "Email Name"
        }).populate({
            path: "BookID",
            select: "Title"
        });

        if (!loan) throw new Error("Loan kh√¥ng t·ªìn t·∫°i");

        const userEmail = loan.AccountID.Email;
        const userName = loan.AccountID.Name;
        const bookTitles = Array.isArray(loan.BookID)
            ? loan.BookID.map(book => book.Title).join(", ")
            : loan.BookID.Title;

        let emailSubject = "";
        let emailContent = "";

        if (state === "Y√™u c·∫ßu m∆∞·ª£n") {
            loan.State = "ƒêang m∆∞·ª£n";

            const oldDayStart = new Date(loan.DayStart);
            const oldDayEnd = new Date(loan.DayEnd);
            const diffTime = Math.abs(oldDayEnd - oldDayStart);
            const countDayBorrowed = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            const nowUTC = new Date();
            loan.DayStart = new Date(nowUTC.getTime() + 7 * 60 * 60 * 1000);
            loan.DayEnd = new Date(loan.DayStart);
            loan.DayEnd.setDate(loan.DayEnd.getDate() + countDayBorrowed);

            const book = await Book.findOne({ _id: loan.BookID });
            book.Availability = "Unavailable";
            book.CountBorrow += 1;

            await loan.save();
            await book.save();

            emailSubject = "üìò ƒê∆°n m∆∞·ª£n s√°ch c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c duy·ªát!";
            emailContent = `
                <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                    <h2 style="color: #2c3e50;">Xin ch√†o ${userName},</h2>
                    <p>üéâ Ch√∫c m·ª´ng! ƒê∆°n m∆∞·ª£n s√°ch c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c <strong>duy·ªát th√†nh c√¥ng</strong>.</p>
                    <p><strong>Th√¥ng tin m∆∞·ª£n s√°ch:</strong></p>
                    <ul>
                        <li><strong>T·ª±a s√°ch:</strong> ${bookTitles}</li>
                        <li><strong>Ng√†y b·∫Øt ƒë·∫ßu:</strong> ${loan.DayStart.toLocaleDateString()}</li>
                        <li><strong>Ng√†y k·∫øt th√∫c:</strong> ${loan.DayEnd.toLocaleDateString()}</li>
                    </ul>
                    <p>üìå Vui l√≤ng ƒë·∫øn <strong>Th∆∞ vi·ªán Tr∆∞·ªùng BokStory</strong> <u>tr∆∞·ªõc 17h ng√†y ${loan.DayStart.toLocaleDateString()}</u> ƒë·ªÉ nh·∫≠n s√°ch v√† ho√†n t·∫•t th·ªß t·ª•c ƒë·∫∑t c·ªçc.</p>
                    <p>N·∫øu b·∫°n kh√¥ng ƒë·∫øn ƒë√∫ng h·∫°n, ƒë∆°n m∆∞·ª£n c√≥ th·ªÉ s·∫Ω b·ªã h·ªßy t·ª± ƒë·ªông.</p>
                    <p>Ch√∫c b·∫°n ƒë·ªçc s√°ch vui v·∫ª v√† h·ªçc t·∫≠p hi·ªáu qu·∫£!</p>
                    <p style="margin-top: 20px;">Tr√¢n tr·ªçng,<br/>Ban qu·∫£n l√Ω Th∆∞ vi·ªán</p>
                    ${getLibrarySignature()}
                </div>
            `;
        } else if (state === "T·ª´ ch·ªëi") {
            loan.State = "ƒê√£ t·ª´ ch·ªëi";

            const book = await Book.findOne({ _id: loan.BookID });
            book.Availability = "Available";

            await loan.save();
            await book.save();

            emailSubject = "üìï ƒê∆°n m∆∞·ª£n s√°ch ƒë√£ b·ªã t·ª´ ch·ªëi";
            emailContent = `
                <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                    <h2 style="color: #c0392b;">Xin ch√†o ${userName},</h2>
                    <p>R·∫•t ti·∫øc, ƒë∆°n m∆∞·ª£n s√°ch c·ªßa b·∫°n v·ªõi ti√™u ƒë·ªÅ <strong>${bookTitles}</strong> ƒë√£ b·ªã t·ª´ ch·ªëi.</p>
                    <p>üìù N·∫øu b·∫°n c√≥ b·∫•t k·ª≥ th·∫Øc m·∫Øc n√†o ho·∫∑c mu·ªën bi·∫øt l√Ω do t·ª´ ch·ªëi, vui l√≤ng li√™n h·ªá v·ªõi th∆∞ vi·ªán qua ƒë·ªãa ch·ªâ email <a href="mailto:${process.env.EMAIL_USER}">${process.env.EMAIL_USER}</a>.</p>
                    <p>Ch√∫ng t√¥i r·∫•t mong ƒë∆∞·ª£c h·ªó tr·ª£ b·∫°n trong nh·ªØng l·∫ßn m∆∞·ª£n ti·∫øp theo.</p>
                    <p style="margin-top: 20px;">Th√¢n √°i,<br/>Ban qu·∫£n l√Ω Th∆∞ vi·ªán</p>
                    ${getLibrarySignature()}
                </div>
            `;
        } else if (state === "ƒêang m∆∞·ª£n") {
            loan.State = "ƒê√£ tr·∫£";

            const nowUTC = new Date();
            loan.DayEnd = new Date(nowUTC.getTime() + 7 * 60 * 60 * 1000);

            const book = await Book.findOne({ _id: loan.BookID });
            book.Availability = "Available";

            await loan.save();
            await book.save();

            emailSubject = "‚úÖ ƒê∆°n m∆∞·ª£n s√°ch ƒë√£ ho√†n t·∫•t";
            emailContent = `
                <div style="font-family: Arial, sans-serif; line-height: 1.6;">
                    <h2 style="color: #27ae60;">Xin ch√†o ${userName},</h2>
                    <p>üéâ C·∫£m ∆°n b·∫°n ƒë√£ tr·∫£ l·∫°i s√°ch ƒë√∫ng h·∫°n. ƒê∆°n m∆∞·ª£n s√°ch c·ªßa b·∫°n v·ªõi ti√™u ƒë·ªÅ <strong>"${bookTitles}"</strong> ƒë√£ ƒë∆∞·ª£c ho√†n t·∫•t.</p>
                    <p>Ch√∫ng t√¥i hy v·ªçng t√†i li·ªáu ƒë√£ h·ªó tr·ª£ t·ªët cho nhu c·∫ßu h·ªçc t·∫≠p ho·∫∑c nghi√™n c·ª©u c·ªßa b·∫°n.</p>
                    <p>üìå ƒê·ª´ng qu√™n ti·∫øp t·ª•c s·ª≠ d·ª•ng c√°c d·ªãch v·ª• v√† ngu·ªìn t√†i li·ªáu h·ªØu √≠ch kh√°c t·ª´ Th∆∞ vi·ªán.</p>
                    <p style="margin-top: 20px;">Th√¢n √°i,<br/>Ban qu·∫£n l√Ω Th∆∞ vi·ªán</p>
                    ${getLibrarySignature()}
                </div>
            `;
        } else {
            throw new Error("Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá");
        }

        const transporter = nodemailer.createTransport({
            service: 'gmail',
            auth: {
                user: process.env.EMAIL_USER,
                pass: process.env.GMAIL_APP_PASSWORD
            }
        });

        await transporter.sendMail({
            from: `"Th∆∞ vi·ªán Tr∆∞·ªùng BokStory" <${process.env.EMAIL_USER}>`,
            to: userEmail,
            subject: emailSubject,
            html: emailContent
        });

        return loan;
    } catch (err) {
        console.error("L·ªói trong loanService.acceptLoanSV: ", err.message);
        throw err;
    }
};

exports.updateLoanById = async(id, { DayStart, DayEnd, State, Note, Payment, Method }) => {
    const loan = await Loan.findById(id);
    if (!loan) {
      const err = new Error('Kh√¥ng t√¨m th·∫•y ƒë∆°n m∆∞·ª£n');
      err.statusCode = 404;
      throw err;
    }
  
    // C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng
    loan.DayStart = DayStart;
    loan.DayEnd   = DayEnd;
    loan.State    = State;
    loan.Note     = Note ?? loan.Note;
    loan.Payment  = Payment;
    loan.Method   = Method;
  
    await loan.save();
    return loan;
}
